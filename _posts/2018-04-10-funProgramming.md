---
layout: post
title: "函数式编程以及高阶函数"
date: 2018-04-15
description: "函数式编程以及高阶函数"
tag: JavaScript
---   

最近开始每周一次技术分享会，这周轮到我，我的分享会主题是《函数式编程以及高阶函数》，看了很多文章，花了周末两天时间整理出来，主要是整理思路以及PPT确实很费时间，还是比较喜欢自己 整理博客或者自由总结东西~~~ 

现在开始简单介绍一下函数式编程，适合新手理解。下面开始进入正题：

### 函数式编程

#### 首先我们来了解一下什么是函数式编程？

在函数式编程语言中，函数是第一类的对象，也就是说，函数 不依赖于任何其他的对象而可以独立存在，而在面向对象的语言中，函数 ( 方法 ) 是依附于对象的，属于对象的一部分。这一点就 决定了函数在函数式语言中的一些特别的性质，比如作为传出 / 传入参数，作为一个普通的变量等。

￥%……&*？ 这说的是啥，没懂，没关系，我也找不到一个统一的函数式编程的定义。

然后看了很多，我总结了下，自己眼中的函数是编程思想。

    基于函数的编程方式，使用不可变值和纯粹的函数，对一个值(集合)进行处理，映射成另一个值（集合）

引用@nameoverflow的这句话：

>> 函数式编程关心数据的映射，命令式编程关心解决问题的步骤

然后下面开始解析一下函数式编程的一些特性：

### 函数是一等公民

“一等”这个术语通常用来描述值。当函数被看作“一等公民”时，那它就可以去任何值可以去的地方，很少有限制。比如数字在 js里就是一等公民，作为一等公民的函数就会拥有类似数字的性质

    var abc = function(){return 42} // 函数与数字一样可以存储为变量

    var abc = [32, function(){return 42}] // 函数与数字一样可以存储为数组的一个元素

    var acb = {number: 32, fun: function(){return 42}} // 函数与数字一样可以作为对象的成员变量

    32 + (function(){return 42}) () // 函数与数字一样可以在使用时直接创建出来

    // 函数与数字一样可以被传递给另一个函数
    function weirdAdd(n, f){ return n + f()}
    weirdAdd(32, function(){return 42})

    // 函数与数字一样可以被另一个函数返回
    return 32;
    return function(){return 42}

### 不可变

>> “可变和共享”是万恶之源

不可变数据其实是函数式编程相关的重要概念。相对的，函数式编程中认为可变性是万恶之源。但是，为什么会有这样的结论呢？
这个问题可能很多程序员都会有。其实，如果你的代码逻辑可变，不要惊慌，这并不是“政治错误”的。比如JS中的数组操作，很对都会对原数组进行直接改变，这当然并没有什么问题。比如：

    let arr = [1, 2, 3, 4, 5];
    arr.splice(1, 1); // 返回[2];
    console.log(arr); // [1, 3, 4, 5];

这是我们常用的“删除数组某一项”的操作。好吧，他一点问题也没有。
问题其实出现在“滥用”可变性上，这样会给你的程序带来“副作用”。先不必关心什么是“副作用”，他又是一个函数式编程的概念。
我们先看一下实例：

    const student1 = {
        school: 'XDF',
        name: 'LYC',
    }

    const changeStudent = (student, newName) => {
        const newStudent = student;
        newStudent.name = newName;
        return newStudent;
    }

    const student2 = changeStudent(student1, 'lyc');

    // both students will have the name properties
    console.log(student1, student2);
    // Object {school: "XDF", name: "lyc"} 
    // Object {school: "XDF", name: "lyc"}

我们发现，尽管创建了一个新的对象student2，但是老的对象student1也被改动了。这是因为JS对象中的赋值是“引用赋值”，即在赋值过程中，传递的是在内存中的引用(memory reference)。

>> 不可变数据使代码更简单和安全。

### 纯函数

    对于相同的输入，永远会得到相同的输出，而且没有任何可观察的副作用，也不依赖外部环境的状态

>> 总结为两点：

>>    1. 函数的返回结果只依赖于它的参数

>>    2. 函数执行过程里面没有副作用

#### 纯函数的第一个条件：一个函数的返回结果只依赖于它的参数。

    const a = 1
    const foo = (b) => a + b
    foo(2) // => 3

foo 函数不是一个纯函数，因为它返回的结果依赖于外部变量 a，我们在不知道 a 的值的情况下，并不能保证 foo(2) 的返回值是 3。虽然 foo 函数的代码实现并没有变化，传入的参数也没有变化，但它的返回值却是不可预料的，现在 foo(2) 是 3，可能过了一会就是 4 了，因为 a 可能发生了变化变成了 2。

    const a = 1
    const foo = (x, b) => x + b
    foo(1, 2) // => 3

现在 foo 的返回结果只依赖于它的参数 x 和 b，foo(1, 2) 永远是 3。今天是 3，明天也是 3，在服务器跑是 3，在客户端跑也 3，不管你外部发生了什么变化，foo(1, 2) 永远是 3。只要 foo 代码不改变，你传入的参数是确定的，那么 foo(1, 2) 的值永远是可预料的。


#### 函数执行过程没有副作用

>> 一个函数执行过程对产生了外部可观察的变化那么就说这个函数是有副作用的

我们稍微修改下foo:

    const a = 1
    const foo = (obj, b) => {
        return obj.x + b
    }
    const counter = { x: 1 }
    foo(counter, 2) // => 3
    counter.x // => 1

我们把原来的 x 换成了 obj，我现在可以往里面传一个对象进行计算，计算的过程里面并不会对传入的对象进行修改，计算前后的 counter 不会发生任何变化，计算前是 1，计算后也是 1，它现在是纯的。但是我再稍微修改一下它：

    const a = 1
    const foo = (obj, b) => {
        obj.x = 2
        return obj.x + b
    }
    const counter = { x: 1 }
    foo(counter, 2) // => 4
    counter.x // => 2

现在情况发生了变化，我在 foo 内部加了一句 obj.x = 2，计算前 counter.x 是 1，但是计算以后 counter.x 是 2。foo 函数的执行对外部的 counter 产生了影响，它产生了副作用，因为它修改了外部传进来的对象，现在它是不纯的

但是你在函数内部构建的变量，然后进行数据的修改没有副作用：

    const foo = (b) => {
        const obj = { x: 1 }
        obj.x = 2
        return obj.x + b
    }

虽然 foo 函数内部修改了 obj，但是 obj 是内部变量，外部程序根本观察不到，修改 obj 并不会产生外部可观察的变化，这个函数是没有副作用的，因此它是一个纯函数。


### 纯函数总结

>> 一个函数的返回结果只依赖于它的参数，并且在执行过程里面没有副作用，我们就把这个函数叫做纯函数。

为什么要煞费苦心地构建纯函数？因为纯函数非常“靠谱”，执行一个纯函数你不用担心它会干什么坏事，它不会产生不可预料的行为，也不会对外部产生影响。不管何时何地，你给它什么它就会乖乖地吐出什么。如果你的应用程序大多数函数都是由纯函数组成，那么你的程序测试、调试起来会非常方便。



